#!/usr/bin/env python3
"""
dynamics.py

Core 6-DoF equations of motion for the aircraft.
"""

import math
import numpy as np
from aero import standard_atmosphere, compute_CL, compute_CD, wind_to_body_rotation
from controls import (compute_elevator_deflection,
                      compute_rudder_deflection,
                      compute_aileron_deflection)

def rotation_matrix_body_to_inertial(phi, theta, psi):
    cphi, sphi = math.cos(phi), math.sin(phi)
    ctheta, stheta = math.cos(theta), math.sin(theta)
    cpsi, spsi = math.cos(psi), math.sin(psi)
    R = np.array([
        [ cpsi*ctheta,  cpsi*stheta*sphi - spsi*cphi,  cpsi*stheta*cphi + spsi*sphi],
        [ spsi*ctheta,  spsi*stheta*sphi + cpsi*cphi,  spsi*stheta*cphi - cpsi*sphi],
        [-stheta,       ctheta*sphi,                  ctheta*cphi]
    ])
    return R

def body_rates_to_euler_rates(phi, theta, omega):
    # p is roll rate, q is pitch rate, r is yaw rate
    # phi is roll angle, theta is pitch angle, psi is yaw angle
    p, q, r = omega
    phi_dot = p + math.sin(phi)*math.tan(theta)*q + math.cos(phi)*math.tan(theta)*r
    theta_dot = math.cos(phi)*q - math.sin(phi)*r
    psi_dot = (math.sin(phi)/math.cos(theta))*q + (math.cos(phi)/math.cos(theta))*r
    return np.array([phi_dot, theta_dot, psi_dot])

def compute_moment_coefficients(alpha_rad, beta_rad, p, q, r, b, MAC, V,
                                CL, delta_elev, delta_rudd, delta_ail):
    
    pb_2V = (p*b)/(2*V)
    qc_2V = (q*MAC)/(2*V)
    rb_2V = (r*b)/(2*V)

    # Roll
    # a positive Cl_beta (rolling moment due to sideslip) indicates that the 
    # aircraft will roll in the opposite direction of the sideslip, w
    # hile a negative Cl_beta means it will roll in the same direction. 
    # In general, a negative Cl_beta is desired for stability, meaning the aircraft
    #  will tend to return to wings-level flight after a sideslip. 
    C_l_beta = -0.10
    # This derivative quantifies how much a rolling moment (a force that causes the aircraft to roll) is affected by the roll rate 
    # (the angular speed of the roll). 
    # A negative value for Cl_p indicates that a positive roll rate will produce a rolling moment that opposes the roll, 
    # damping the motion
    C_l_p    = -0.45
    # c_l_r refers to the rolling moment coefficient due to yaw rate. 
    # This coefficient represents the rolling moment generated on an aircraft due to its rate of 
    # rotation about the vertical axis (yaw). A positive c_l_r value indicates that a yawing motion 
    # (left or right turn) tends to generate a rolling motion in the same direction. 
    C_l_r    = 0.08
    # This term represents the derivative of Cl with respect to aileron deflection. It's a measure of how effectively the ailerons can control the aircraft's roll. A positive clδa indicates that a positive aileron deflection (e.g., left aileron down, right aileron up) will increase lift on the 
    # left wing and decrease lift on the right, causing a roll to the left. 
    C_l_da   = 0.5

    # pitch
    # The pitching moment coefficient at zero angle of attack, often denoted as \(C_{m_{0}}\), represents the pitching moment 
    # experienced by a wing or airfoil when the angle of attack is zero. This moment exists even at zero lift, and it's often negative, meaning it tends to pitch the wing down. 
    C_m0 = 0.04
    # Cmα (pitching moment coefficient with respect to the angle of attack) is a crucial parameter. 
    # It represents the change in pitching moment for a given change in the angle of attack.
    # A negative Cmα indicates that increasing the angle of attack will result in a negative pitching moment (making the aircraft pitch down), which is generally desirable for static stability. 
    C_m_alpha = -0.5
    # pitching moment derivative A negative C_m_q is associated with static stability, meaning the aircraft tends to return to its original pitch angle after a disturbance, 
    # while a positive C_m_q indicates static instability, where the aircraft will continue to pitch away from its original attitude. 
    C_m_q = -15.0
    # represents the change in pitching moment coefficient due to a change in elevator deflection (delta_e). It's a crucial parameter in determining the effectiveness of the elevator in controlling the pitch of the aircraft.
    # A positive Cm_delta_e indicates that a positive elevator deflection will produce a nose-down pitching moment
    # Increasing it can be dangerous as it leads the airplane drop its altitude
    C_m_de  = -1.0

    # Yaw
    # A positive Cn_beta is generally desired for aircraft stability, as it ensures that the aircraft will tend to return to a straight and level flight path after being disturbed by a sideslip. 
    # This is because the force generated by a positive Cn_beta will counteract the sideslip and help the aircraft maintain its course. 
    C_n_beta = 0.10
    C_n_p    = -0.02
    # A negative Cnr value (which is common) helps to make an aircraft more stable in yaw. 
    # When the aircraft is yawing to one side, the Cnr term would create a yawing moment that 
    # counteracts this movement, helping to restore it to a straight-ahead flight path. 
    C_n_r  = -0.15
    # Imagine a rudder, a movable control surface on the tail of an aircraft, 
    # that controls the aircraft's yaw. Cn δr tells us how much the aircraft will yaw (turn left or right) 
    # for a given rudder deflection. A larger Cn δr value means the rudder is more powerful at controlling yaw. 
    # If an aircraft is yawing to the right (positive yaw rate), the pilot might deflect the rudder to the left (positive delta r) to create a negative yawing moment that will counter the yaw and return the aircraft to a straight heading. 
    C_n_dr = -0.2

    C_l = (C_l_beta*beta_rad + C_l_p*pb_2V + C_l_r*rb_2V + C_l_da*delta_ail)
    C_m = (C_m0 + C_m_alpha*alpha_rad + C_m_q*qc_2V + C_m_de*delta_elev)
    C_n = (C_n_beta*beta_rad + C_n_p*pb_2V + C_n_r*rb_2V + C_n_dr*delta_rudd)

    return C_l, C_m, C_n

def six_dof_odes(t, X, params, wind_ned):
    # X is the state vector
    # X[0:3] = position in NED frame
    # X[3:6] = body velocities in body frame
    # X[6:9] = euler angles in body frame
    # X[9:12] = angular rates in body frame
    pos = X[0:3]
    vel_body = X[3:6]
    euler = X[6:9]
    omega = X[9:12]

    phi, theta, psi = euler
    p, q, r = omega

    m = params["m"]
    I = params["I"]
    I_inv = params["I_inv"]
    S = params["S"]
    b = params["b"]
    MAC = params["MAC"]
    cd0 = params["cd0"]
    k   = params["k"]
    T   = params["T"]
    altitude = -pos[2]

    # atmosphere
    _, _, rho, _ = standard_atmosphere(altitude)

    # transform wind to body
    Rotation_body_to_inertial = rotation_matrix_body_to_inertial(phi, theta, psi)
    wind_body = Rotation_body_to_inertial.T @ wind_ned
    # vel_rel_body is the vector for airspeed in the body frame
    # Magnitude of Vel_body vector is the ground speed in the body frame(GS indicated airspeed)
    vel_rel_body = vel_body - wind_body
    # V_true is the TAS indicated airspeed
    # The pitot tube measures the dynamic pressure of the air flowing into it, which is proportional to the square of the true airspeed
    V_true = np.linalg.norm(vel_rel_body)
    q_dyn = 0.5*rho*(V_true**2)
    # alpha_rad is the angle of attack(AOA)
    # beta_rad is the sideslip angle
    # AOA is the angle between the relative wind and the chord line of the wing or the angle between stability axis and body axis
    # sideslip is the angle between the relative wind and the stability axis
    # Update the angle of attack and sideslip
    alpha_rad = math.atan2(vel_rel_body[2], vel_rel_body[0])
    beta_rad =  math.asin(vel_rel_body[1]/V_true)
    
    # control deflections
    delta_elev = compute_elevator_deflection(alpha_rad, q,  alpha_trim_deg=0.0)
    #delta_elev = 0
    delta_rudd = compute_rudder_deflection(psi, r, desired_psi=0.0)
    delta_ail  = compute_aileron_deflection(phi, p, desired_phi=0.0)
    # Lift and drag coefficients in the wind frame
    CL = compute_CL(alpha_rad)
    CD = compute_CD(CL, cd0, k)
    # Side force coefficient in the wind frame
    CY = 0.5*beta_rad

    Rotation_wind_to_body = wind_to_body_rotation(alpha_rad, beta_rad)
    F_wind_coeffs = np.array([-CD, -CY, -CL])
    F_body_coeffs = Rotation_wind_to_body @ F_wind_coeffs

    F_aero_body   = F_body_coeffs * q_dyn * S
    F_thrust_body = np.array([T, 0.0, 0.0])

    mg_inertial = np.array([0.0, 0.0, m*9.81])
    F_grav_body = Rotation_body_to_inertial.T @ mg_inertial

    F_total_body = F_aero_body + F_thrust_body + F_grav_body
    accel_body = F_total_body/m
    vel_dot_body = accel_body - np.cross(omega, vel_body)

    # moment coefficients about the center of gravity
    C_l, C_m, C_n = compute_moment_coefficients(alpha_rad, beta_rad,
                                               p, q, r,
                                               b, MAC, V_true,
                                               CL, delta_elev, delta_rudd, delta_ail)
    
    
    M_aero = np.array([
        q_dyn*S*b*C_l,
        q_dyn*S*MAC*C_m,
        q_dyn*S*b*C_n
    ])
    # Rotational equations of motion
    # I_inv is the inverse of the inertia matrix
    omega_dot = I_inv @ (M_aero - np.cross(omega, I@omega))

    euler_dot = body_rates_to_euler_rates(phi, theta, omega)

    dX = np.zeros_like(X)
    dX[0:3]   = Rotation_body_to_inertial @ vel_body
    dX[3:6]   = vel_dot_body
    dX[6:9]   = euler_dot
    dX[9:12]  = omega_dot


    return dX
